{
  generate = [java="8"]
  parserClass="com.github.sblundy.elvish.lang.ElvishParser"
  parserUtilClass="com.github.sblundy.elvish.lang.ElvishParserUtils"
  parserImports = [
    'static com.intellij.lang.parser.GeneratedParserUtilBase.*'
  ]
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Elvish"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.sblundy.elvish.psi"
  psiImplPackage="com.github.sblundy.elvish.psi.impl"

  elementTypeHolderClass="com.github.sblundy.elvish.psi.ElvishTypes"
  elementTypeClass="com.github.sblundy.elvish.psi.ElvishElementType"
  tokenTypeClass="com.github.sblundy.elvish.psi.ElvishTokenType"

  tokens=[
    COMMENT='regexp://.*'
    OPEN_BRACE="{"
    CLOSE_BRACE="}"
    OPEN_BRACKET="["
    CLOSE_BRACKET="]"
    OPEN_PARAN="("
    CLOSE_PARAN=")"
    SINGLE_QUOTE="'"
    DOUBLE_QUOTE="\""
    AMPERSAND="&"
    QUESTION="?"
    DOLLAR_SIGN="$"
    TILDE="~"
    EQUALS="="
    AT_SYMBOL="@"
    WILDCARD="*"
    INLINE_WHITESPACE="regexp:[ \t]+"
    EOL="regexp:\r|\n|\r\n"
    TEXT
    ESCAPED_QUOTED_TEXT
    INVALID_ESCAPED_QUOTED_TEXT
    PIPE="|"
    SEMICOLON=";"
    BAREWORD_CHAR="regexp:[.@%+!]"
    VARIABLE_CHAR="regexp:[0-9a-zA-Z\-_:~]"
    COMMAND_BAREWORD_CHAR="regexp:[<>*^]"
    COLON=":"
    BACKSLASH="/"
    COMMA=","
    WILDCARD="*"
    KEYWORD_ELSE="else"
    KEYWORD_ELIF="elif"
    KEYWORD_WHILE="while"
    KEYWORD_EXCEPT="except"
    KEYWORD_FINALLY="finally"
    KEYWORD_FOR="for"
    KEYWORD_IF="if"
    KEYWORD_TRY="try"
    KEYWORD_DEL="del"
    KEYWORD_FN="fn"
    KEYWORD_USE="use"
    CONTINUATION="regexp:[\\^][\r|\n]"
  ]

  generateTokenAccessors(".*Capture")=true
}
script ::= Chunk
Chunk ::= ChuckSep* ( Pipeline ChuckSep* )* {
  extends="com.github.sblundy.elvish.psi.ElvishChunkBase"
}
private ChuckSep ::= PipelineSep | Space
PipelineSep ::= EOL | SEMICOLON
private Space ::= INLINE_WHITESPACE
private Pipeline ::= Form Space? PipelineExtension*
private PipelineExtension ::= PIPE Space? (EOL Space?)? Form Space?
private Form ::= AssignmentOnlyForm | SpecialCommand | CommandForm
private AssignmentOnlyForm ::= Space? Assignment Space?

// Barewords and strings
SingleQuoted ::= SINGLE_QUOTE (TEXT|ESCAPED_QUOTED_TEXT|INVALID_ESCAPED_QUOTED_TEXT)* SINGLE_QUOTE
DoubleQuoted ::= DOUBLE_QUOTE (TEXT|ESCAPED_QUOTED_TEXT|INVALID_ESCAPED_QUOTED_TEXT)* DOUBLE_QUOTE
private Primary ::= Bareword | SingleQuoted | DoubleQuoted | VariableRef | WILDCARD | TILDE | ExceptionCapture | OutputCapture | Lambda | List | Map | Braced
Variable ::= NamespaceName? VariableName {
  extends="com.github.sblundy.elvish.psi.ElvishVariableBase"
  implements="com.github.sblundy.elvish.psi.ElvishVariableDeclaration"
}
NamespaceName ::= (VariableName COLON)+
VariableName ::= VARIABLE_CHAR+
VariableRef ::= DOLLAR_SIGN AT_SYMBOL? VariableRefName Index* {
  extends="com.github.sblundy.elvish.psi.ElvishVariableRefBase"
  implements="com.github.sblundy.elvish.psi.ReferenceWithNamespacePsiElement"
}
private VariableRefName ::= NamespaceName? VariableName
Bareword ::= (VARIABLE_CHAR|BAREWORD_CHAR|BACKSLASH|COMMA|<<parseKeywordAsBareword>>)+
BracedBareword ::= (VARIABLE_CHAR|BAREWORD_CHAR|BACKSLASH|<<parseKeywordAsBareword>>)+
CommandBareword ::= (VARIABLE_CHAR|BAREWORD_CHAR|COMMAND_BAREWORD_CHAR|WILDCARD|BACKSLASH|EQUALS)+

// Maps and lists
Compound ::= TILDE? Indexing+
private Indexing ::= Primary Index*
private Index ::= OPEN_BRACKET (IndexRange | IndexSingle) CLOSE_BRACKET
{ pin=1 }
private IndexValue ::= VariableName | SingleQuoted | DoubleQuoted | VariableRef | ExceptionCapture | OutputCapture
IndexSingle ::= IndexValue+
IndexRange ::= IndexValue+ IndexRangeSeparator IndexValue+
private IndexRangeSeparator ::= COLON | <<parseIfFlag "NewSliceIndex" NewSliceIndexString>>
private NewSliceIndexString ::= '..=' | '..'
Array ::= ArraySpace* (Compound ArraySpace*)*
private ArraySpace ::= Space | EOL
List ::= OPEN_BRACKET Array CLOSE_BRACKET
Map ::= EmptyMap | MapWithValues
private MapWithValues ::= OPEN_BRACKET ArraySpace* (MapPair ArraySpace*)+ CLOSE_BRACKET
private EmptyMap ::= OPEN_BRACKET Space? AMPERSAND Space? CLOSE_BRACKET
MapPair ::= AMPERSAND Space? Compound EQUALS Space? Compound

// Commands
Assignment ::= (Variable Index* Space?)+ EQUALS Space? Compound {
  pin=2
  extends="com.github.sblundy.elvish.psi.ElvishAssignmentBase"
}

private CommandForm ::= head (CommandSep+ argument)* AMPERSAND?
private CommandSep ::= Space | CONTINUATION
head ::= CommandExpression | SingleQuoted | DoubleQuoted | VariableRef | ExceptionCapture | OutputCapture
argument ::=  Redir | MapPair | Compound | ExitusRedir
CommandExpression ::= NamespaceName* CommandBareword{
  extends="com.github.sblundy.elvish.psi.ElvishCommandExpressionBase"
  implements="com.github.sblundy.elvish.psi.ReferenceWithNamespacePsiElement"
}

ExitusRedir ::= QUESTION '>' Space? Compound
Redir ::= RedirFD? RedirMode Space? ( AMPERSAND? Compound? )
private RedirMode ::= '<' | '>' | '<>' | '>>'
private RedirFD ::= '0' | '1' | '2'

ExceptionCapture ::= QUESTION OPEN_PARAN Chunk CLOSE_PARAN
OutputCapture ::= OPEN_PARAN Chunk CLOSE_PARAN

Lambda ::= LambdaArguments? OPEN_BRACE Chunk CLOSE_BRACE {
  extends="com.github.sblundy.elvish.psi.ElvishLambdaBase"
}
LambdaArguments ::=OPEN_BRACKET Space? ((parameter | MapPair) Space?)* CLOSE_BRACKET
parameter ::= AT_SYMBOL? VariableName {
  extends="com.github.sblundy.elvish.psi.ElvishParameterBase"
  implements="com.github.sblundy.elvish.psi.ElvishVariableDeclaration"
}
Braced ::= OPEN_BRACE (Space | EOL)* BracedBareword (BracedSep* BracedBareword)* (Space | EOL)* CLOSE_BRACE
BracedSep ::= (Space | EOL)* COMMA (Space | EOL)*

// Special Commands

private SpecialCommand ::= DeleteCommand | UseCommand | LogicCommand | IfCommand | WhileCommand | ForCommand | TryCommand | FnCommand

DeleteCommand ::= KEYWORD_DEL CommandSep* Variable Index*
LogicCommand ::= LogicCMD (CommandSep* argument)* CommandSep*
private LogicCMD ::= 'or' | 'and'
IfCommand ::= KEYWORD_IF Space Condition Space OPEN_BRACE Chunk CLOSE_BRACE (Space ElIfBlock)* (Space ElseBlock)?
Condition ::= VariableRef | ExceptionCapture | OutputCapture
ElIfBlock ::= KEYWORD_ELIF Space Condition Space OPEN_BRACE Chunk CLOSE_BRACE
ElseBlock ::= KEYWORD_ELSE Space OPEN_BRACE Chunk CLOSE_BRACE
WhileCommand ::= KEYWORD_WHILE Space Condition Space OPEN_BRACE Chunk CLOSE_BRACE (Space ElseBlock)?
ForCommand ::= KEYWORD_FOR Space Variable Space Collection Space OPEN_BRACE Chunk CLOSE_BRACE (Space ElseBlock)? {
  implements="com.github.sblundy.elvish.psi.ElvishVariableDeclaringBlock"
}
Collection ::= List | Map | VariableRef | ExceptionCapture | OutputCapture
TryCommand ::= KEYWORD_TRY Space OPEN_BRACE Chunk CLOSE_BRACE (Space ExceptBlock)? (Space ElseBlock)? (Space FinallyBlock)?
ExceptBlock ::= KEYWORD_EXCEPT Space Variable Space OPEN_BRACE Chunk CLOSE_BRACE {
  implements="com.github.sblundy.elvish.psi.ElvishVariableDeclaringBlock"
}
FinallyBlock ::= KEYWORD_FINALLY Space OPEN_BRACE Chunk CLOSE_BRACE
FnCommand ::= KEYWORD_FN Space VariableName Space LambdaArguments? OPEN_BRACE Chunk CLOSE_BRACE {
  extends="com.github.sblundy.elvish.psi.FnCommandBase"
  implements="com.github.sblundy.elvish.psi.ElvishFunctionDeclaration"
  methods=[commandName="VariableName"]
}
UseCommand ::= KEYWORD_USE Space (RelativeModuleSpec | LibModuleSpec) (Space ModuleAlias)?
LibModuleSpec ::= (VARIABLE_CHAR+'.')* ModulePathSegment* (VariableName COLON)* VariableName
RelativeModuleSpec ::= <<parseIfFlag "UseRelativeModules" RelativeModuleSpecInner>>
private RelativeModuleSpecInner ::= ('./' | '../') (ModulePathSegment | './' | '../')* (VariableName COLON)* VariableName
private ModulePathSegment ::= VARIABLE_CHAR+ BACKSLASH
ModuleAlias ::= <<parseIfFlag "UseWithOptionalRename" VariableName>>