{
  generate = [java="8"]
  parserClass="com.github.sblundy.elvish.lang.ElvishParser"
  parserUtilClass="com.github.sblundy.elvish.lang.ElvishParserUtils"
  parserImports = [
    'static com.intellij.lang.parser.GeneratedParserUtilBase.*'
  ]
  extends="com.github.sblundy.elvish.psi.ASTWrapperElvishPsiElement"
  implements="com.github.sblundy.elvish.psi.ElvishPsiElement"

  psiClassPrefix="Elvish"
  psiImplClassSuffix="Impl"
  psiImplUtilClass="com.github.sblundy.elvish.psi.ElvishPsiImplUtil"
  psiPackage="com.github.sblundy.elvish.psi"
  psiImplPackage="com.github.sblundy.elvish.psi.impl"

  elementTypeHolderClass="com.github.sblundy.elvish.psi.ElvishTypes"
  elementTypeClass="com.github.sblundy.elvish.psi.ElvishElementType"
  tokenTypeClass="com.github.sblundy.elvish.psi.ElvishTokenType"

  tokens=[
    COMMENT='regexp://.*'
    OPEN_BRACE="{"
    CLOSE_BRACE="}"
    OPEN_BRACKET="["
    CLOSE_BRACKET="]"
    OPEN_PARAN="("
    CLOSE_PARAN=")"
    SINGLE_QUOTE="'"
    DOUBLE_QUOTE="\""
    AMPERSAND="&"
    QUESTION="?"
    DOLLAR_SIGN="$"
    TILDE="~"
    EQUALS="="
    AT_SYMBOL="@"
    WILDCARD="*"
    INLINE_WHITESPACE="regexp:[ \t]+"
    EOL="regexp:\r|\n|\r\n"
    TEXT
    ESCAPED_QUOTED_TEXT
    INVALID_ESCAPED_QUOTED_TEXT
    PIPE="|"
    SEMICOLON=";"
    BAREWORD_CHAR="regexp:[.@%+!]"
    VARIABLE_CHAR="regexp:[0-9a-zA-Z\-_:~]"
    COMMAND_BAREWORD_CHAR="regexp:[<>*^]"
    COLON=":"
    BACKSLASH="/"
    COMMA=","
    WILDCARD="*"
    KEYWORD_ELSE="else"
    KEYWORD_ELIF="elif"
    KEYWORD_WHILE="while"
    KEYWORD_EXCEPT="except"
    KEYWORD_FINALLY="finally"
    KEYWORD_FOR="for"
    KEYWORD_IF="if"
    KEYWORD_TRY="try"
    KEYWORD_DEL="del"
    KEYWORD_FN="fn"
    KEYWORD_USE="use"
    CONTINUATION="regexp:[\\^][\r|\n]"
  ]

  generateTokenAccessors(".*Capture")=true
}
script ::= Chunk
Chunk ::= ChuckSep* ( Pipeline ChuckSep* )*
private ChuckSep ::= PipelineSep | Space
PipelineSep ::= EOL | SEMICOLON
private Space ::= INLINE_WHITESPACE
private Pipeline ::= Form Space? PipelineExtension*
private PipelineExtension ::= PIPE Space? (EOL Space?)? Form Space?
private Form ::= AssignmentOnlyForm | SpecialCommand | CommandForm
private AssignmentOnlyForm ::= Space? Assignment Space?

fake LexicalScope ::= {}
fake NamespaceIdentifier ::= {}
fake VariableReference ::= VariableName
fake ExternalVariableReference ::= NamespaceIdentifier VariableName {
  extends=VariableReference
}
fake VariableDeclaration ::= VariableName
fake VariableAssignment ::= VariableName
fake FunctionDeclaration ::= VariableName {
  methods=[commandName="VariableName"]
}
// Barewords and strings
SingleQuoted ::= SINGLE_QUOTE (TEXT|ESCAPED_QUOTED_TEXT|INVALID_ESCAPED_QUOTED_TEXT)* SINGLE_QUOTE
DoubleQuoted ::= DOUBLE_QUOTE (TEXT|ESCAPED_QUOTED_TEXT|INVALID_ESCAPED_QUOTED_TEXT)* DOUBLE_QUOTE
private Primary ::= Bareword | SingleQuoted | DoubleQuoted | SpecialScopeVariableRef | NamespaceVariableRef | VariableRef | WILDCARD | TILDE | ExceptionCapture | OutputCapture | Lambda | List | Map | Braced
Variable ::= VariableName {
  extends="VariableAssignment"
  implements=[
   "VariableDeclaration"
   "com.intellij.psi.PsiNameIdentifierOwner"
  ]
  methods=[getNameIdentifier getName setName getTextOffset getIcon getPresentation]
}
LocalScopeVariableAssignment ::= LocalNamespace VariableName {
  extends="VariableAssignment"
  implements=[
   "VariableDeclaration"
   "com.intellij.psi.PsiNameIdentifierOwner"
  ]
  methods=[NamespaceIdentifier="LocalNamespace" getNameIdentifier getName setName getTextOffset getIcon getPresentation]
}
UpScopeVariableAssignment ::= UpNamespace VariableName {
  extends="VariableAssignment"
  methods=[NamespaceIdentifier="UpNamespace" getName getTextOffset getIcon getPresentation getReference]
}
NamespaceVariableAssignment ::= (EnvVarNamespace | BuiltinNamespace | NamespaceName) VariableName {
  extends="VariableAssignment"
  implements="ExternalVariableReference"
  methods=[getName isWritable getTextOffset getIcon getPresentation getReference]
}
NamespaceName ::= (VariableName COLON)+ {
  extends="NamespaceIdentifier"
}
LocalNamespace ::= 'local:' {
  extends="NamespaceIdentifier"
}
UpNamespace ::= 'up:' {
  extends="NamespaceIdentifier"
}
ExternalsNamespace ::= 'e:' {
  extends="NamespaceIdentifier"
}
EnvVarNamespace ::= 'E:' {
  extends="NamespaceIdentifier"
}
BuiltinNamespace ::= 'builtin:' {
  extends="NamespaceIdentifier"
}
VariableName ::= VARIABLE_CHAR+
VariableRef ::= DOLLAR_SIGN AT_SYMBOL? VariableName Index* {
  extends=VariableReference
  methods=[getReference]

}
SpecialScopeVariableRef ::= DOLLAR_SIGN AT_SYMBOL? (LocalNamespace | UpNamespace) VariableName Index* {
  extends=VariableReference
  methods=[getReference]
}
NamespaceVariableRef ::= DOLLAR_SIGN (EnvVarNamespace | BuiltinNamespace | NamespaceName) VariableName Index* {
  extends="ExternalVariableReference"
  methods=[getReference]
}

Bareword ::= (VARIABLE_CHAR|BAREWORD_CHAR|BACKSLASH|COMMA|<<parseKeywordAsBareword>>)+
BracedBareword ::= (VARIABLE_CHAR|BAREWORD_CHAR|BACKSLASH|<<parseKeywordAsBareword>>)+
CommandBareword ::= (VARIABLE_CHAR|BAREWORD_CHAR|COMMAND_BAREWORD_CHAR|WILDCARD|BACKSLASH|EQUALS)+

// Maps and lists
Compound ::= TILDE? Indexing+
private Indexing ::= Primary Index*
private Index ::= OPEN_BRACKET (IndexRange | IndexSingle) CLOSE_BRACKET
{ pin=1 }
private IndexValue ::= VariableName | SingleQuoted | DoubleQuoted | SpecialScopeVariableRef | NamespaceVariableRef | VariableRef | ExceptionCapture | OutputCapture
IndexSingle ::= IndexValue+
IndexRange ::= IndexValue+ IndexRangeSeparator IndexValue+
private IndexRangeSeparator ::= COLON | &NewSliceIndexFlag NewSliceIndexString
private NewSliceIndexString ::= '..=' | '..'
Array ::= ArraySpace* (Compound ArraySpace*)*
private ArraySpace ::= Space | EOL
List ::= OPEN_BRACKET Array CLOSE_BRACKET
Map ::= EmptyMap | MapWithValues
private MapWithValues ::= OPEN_BRACKET ArraySpace* (MapPair ArraySpace*)+ CLOSE_BRACKET
private EmptyMap ::= OPEN_BRACKET Space? AMPERSAND Space? CLOSE_BRACKET
MapPair ::= AMPERSAND Space? Compound EQUALS Space? Compound

// Commands
Assignment ::= ((LocalScopeVariableAssignment | UpScopeVariableAssignment | NamespaceVariableAssignment | Variable) Index* Space?)+ EQUALS Space? Compound {
  pin=2
  methods=[value="Compound"]
}

private CommandForm ::= head (CommandSep+ argument)* AMPERSAND?
private CommandSep ::= Space | CONTINUATION
head ::= SpecialScopeCommandExpression | NamespaceCommandExpression | CommandExpression | SingleQuoted | DoubleQuoted | SpecialScopeVariableRef | NamespaceVariableRef | VariableRef | ExceptionCapture | OutputCapture
argument ::=  Redir | MapPair | Compound | ExitusRedir
fake Command ::= CommandBareword {
  methods=[commandName="CommandBareword"]
}
CommandExpression ::= CommandBareword {
  extends="Command"
  methods=[commandName="CommandBareword" getReference]
}
SpecialScopeCommandExpression ::= (LocalNamespace | UpNamespace) CommandBareword {
  extends="Command"
  methods=[commandName="CommandBareword" getReference]
}
NamespaceCommandExpression ::= (ExternalsNamespace | BuiltinNamespace | NamespaceName)  CommandBareword {
  extends="Command"
  methods=[commandName="CommandBareword" getReference]
}

ExitusRedir ::= QUESTION '>' Space? Compound
Redir ::= RedirFD? RedirMode Space? ( AMPERSAND? Compound? )
private RedirMode ::= '<' | '>' | '<>' | '>>'
private RedirFD ::= '0' | '1' | '2'

ExceptionCapture ::= QUESTION OPEN_PARAN Chunk CLOSE_PARAN
OutputCapture ::= OPEN_PARAN Chunk CLOSE_PARAN

Lambda ::= LambdaArguments? OPEN_BRACE Chunk CLOSE_BRACE {
  extends="LexicalScope"
}
LambdaArguments ::=OPEN_BRACKET Space? ((parameter | MapPair) Space?)* CLOSE_BRACKET
parameter ::= AT_SYMBOL? VariableName {
  extends="VariableDeclaration"
  implements=["com.intellij.psi.PsiNameIdentifierOwner"]
  methods=[getNameIdentifier getName setName getIcon getPresentation]
}
Braced ::= OPEN_BRACE (Space | EOL)* BracedBareword (BracedSep* BracedBareword)* (Space | EOL)* CLOSE_BRACE
BracedSep ::= (Space | EOL)* COMMA (Space | EOL)*

// Special Commands

private SpecialCommand ::= DeleteCommand | UseCommand | LogicCommand | IfCommand | WhileCommand | ForCommand | TryCommand | FnCommand

LambdaBlock ::= OPEN_BRACE Chunk CLOSE_BRACE {
  extends="LexicalScope"
}
DeleteCommand ::= KEYWORD_DEL CommandSep* Variable Index*
LogicCommand ::= LogicCMD (CommandSep* argument)* CommandSep*
private LogicCMD ::= 'or' | 'and'
private MissingLambda ::= EOL <<missingLambdaBody>>
IfCommand ::= KEYWORD_IF Space Condition Space (IfBody | MissingLambda)  { pin=1 }
private IfBody ::= LambdaBlock (Space ElIfBlock)* (Space ElseBlock)?
Condition ::= SpecialScopeVariableRef | NamespaceVariableRef | VariableRef | ExceptionCapture | OutputCapture
ElIfBlock ::= KEYWORD_ELIF Space Condition Space (LambdaBlock | MissingLambda)
ElseBlock ::= KEYWORD_ELSE Space (LambdaBlock | MissingLambda)
WhileCommand ::= KEYWORD_WHILE Space Condition Space (WhileCommandBody | MissingLambda)
private WhileCommandBody ::= OPEN_BRACE Chunk CLOSE_BRACE (Space ElseBlock)?
ForCommand ::= KEYWORD_FOR Space Variable Space Collection Space (ForCommandBody | MissingLambda)
private ForCommandBody ::= OPEN_BRACE Chunk CLOSE_BRACE (Space ElseBlock)?
Collection ::= List | Map | SpecialScopeVariableRef | NamespaceVariableRef | VariableRef | ExceptionCapture | OutputCapture
TryCommand ::= KEYWORD_TRY Space LambdaBlock (Space ExceptBlock)? (Space ElseBlock)? (Space FinallyBlock)?
ExceptBlock ::= KEYWORD_EXCEPT Space Variable Space OPEN_BRACE Chunk CLOSE_BRACE {
  extends="LexicalScope"
}
FinallyBlock ::= KEYWORD_FINALLY Space LambdaBlock
FnCommand ::= KEYWORD_FN Space VariableName Space LambdaArguments? OPEN_BRACE Chunk CLOSE_BRACE {
  extends="FunctionDeclaration"
  implements=["LexicalScope" "com.intellij.psi.PsiNameIdentifierOwner"]
  methods=[commandName="VariableName" getNameIdentifier getName setName getTextOffset getIcon getPresentation]
}
UseCommand ::= KEYWORD_USE Space (RelativeModuleSpec | LibModuleSpec) (Space ModuleAlias)?
fake ModuleSpec ::= {}

LibModuleSpec ::= (VARIABLE_CHAR+'.')* ModulePathSegment* (VariableName COLON)* VariableName {
  extends="ModuleSpec"
}
RelativeModuleSpec ::= &UseRelativeModulesFlag RelativeModuleSpecInner {
  extends="ModuleSpec"
}
private RelativeModuleSpecInner ::= ('./' | '../') (ModulePathSegment | './' | '../')* (VariableName COLON)* VariableName
private ModulePathSegment ::= VARIABLE_CHAR+ BACKSLASH
ModuleAlias ::= &UseWithOptionalRenameFlag VariableName

private external UseWithOptionalRenameFlag ::= ifFlag "UseWithOptionalRename"
private external UseRelativeModulesFlag ::= ifFlag "UseRelativeModules"
private external NewSliceIndexFlag ::= ifFlag "NewSliceIndex"
