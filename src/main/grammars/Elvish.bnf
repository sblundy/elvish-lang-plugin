{
  parserClass="com.github.sblundy.elvish.lang.ElvishParser"
  parserUtilClass="com.github.sblundy.elvish.lang.ElvishParserUtils"
  parserImports = [
    'static com.intellij.lang.parser.GeneratedParserUtilBase.*'
  ]
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Elvish"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.sblundy.elvish.psi"
  psiImplPackage="com.github.sblundy.elvish.psi.impl"

  elementTypeHolderClass="com.github.sblundy.elvish.psi.ElvishTypes"
  elementTypeClass="com.github.sblundy.elvish.psi.ElvishElementType"
  tokenTypeClass="com.github.sblundy.elvish.psi.ElvishTokenType"

  tokens=[
    COMMENT='regexp://.*'
    OPEN_BRACE="open_brace"
    CLOSE_BRACE="close_brace"
    OPEN_BRACKET="open_bracket"
    CLOSE_BRACKET="close_bracket"
    OPEN_PARAN="open_paran"
    CLOSE_PARAN="close_paran"
    SINGLE_QUOTE="'"
    DOUBLE_QUOTE="\""
    AMPERSAND="&"
    QUESTION="?"
    TILDA="~"
    EQUALS="="
    INLINE_WHITESPACE="regexp:[ \t]+"
    EOL="regexp:\r|\n|\r\n"
    TEXT="."
    KEYWORD_ELSE="else"
    KEYWORD_ELIF="elif"
    KEYWORD_WHILE="while"
    KEYWORD_EXCEPT="except"
    KEYWORD_FINALLY="finally"
    KEYWORD_FOR="for"
    KEYWORD_IF="if"
    KEYWORD_TRY="try"
    KEYWORD_DEL="del"
    KEYWORD_FN="fn"
    ESCAPED_QUOTED_TEXT="escaped_sequence"
    INVALID_ESCAPED_QUOTED_TEXT="invalid_escaped_sequence"
    CONTINUATION="continuation"
    VAR_REF="VAR_REF"
    PIPE="pipe"
    COMMAND_BAREWORD
    BAREWORD
    VARIABLE
    AT_VARIABLE="@VARIABLE"
  ]
  mixin("variable_declaration")="com.github.sblundy.elvish.psi.ElvishVariableDeclarationMixin"
}

script ::= command* <<eof>>
private bareword ::= AT_VARIABLE | VARIABLE | BAREWORD

// commands

pipeline ::= pipeline_prv
private pipeline_head ::= pipeline_prv | pipeline_element
private pipeline_prv ::= pipeline_element PIPE pipeline_head
private pipeline_element ::= special_command | ordinary_command
private command ::= special_command | assignment | pipeline | ordinary_command

ordinary_command ::= head argument_list
private  argument_list ::= <<parseArgList argument_inner line_terminator>>
private argument_inner ::= option_value | redirection | argument
redirection ::= redirection_operator redirection_target
private redirection_target ::= compound_expression | variable_ref | double_quoted_string | single_quoted_string | compound_expression_bareword_inner
private redirection_operator ::= '0<>' | '1<>' | '2<>' |'0<' | '1<' | '2<' | '0>>' | '1>>' | '2>>' | '0>' | '1>' | '2>' | '<>' | '>>' | '>' | '<'

argument ::= assignment_right
option_value ::= AMPERSAND(VARIABLE)EQUALS(assignment_right)
head ::= bareword | COMMAND_BAREWORD | variable_ref

assignment ::= assignment_left+ EQUALS assignment_right
private assignment_right ::= output_capture | lambda | map_or_list | empty_map | assignable_string
private assignment_left ::= VARIABLE(variable_index)?

// maps and lists

map_or_list ::= OPEN_BRACKET item* CLOSE_BRACKET
empty_map ::= OPEN_BRACKET(AMPERSAND)CLOSE_BRACKET
private item ::= assignment_right | map_entry
map_entry ::= AMPERSAND(bareword|single_quoted_string|double_quoted_string)EQUALS(assignment_right)?
// strings

private assignable_string ::= compound_expression | variable_ref | single_quoted_string | double_quoted_string | bareword
compound_expression ::= compound_expression_capture | compound_expression_var | compound_expression_single_quoted | compound_expression_double_quoted | compound_expression_bareword
private compound_expression_var ::= <<parseCompoundExpressionSegment variable_ref compound_expression_var_following>>
private compound_expression_var_following ::= (compound_expression_capture | compound_expression_single_quoted | compound_expression_double_quoted | compound_expression_bareword | compound_expression_var | output_capture | single_quoted_string | double_quoted_string | variable_ref | compound_expression_bareword_inner)
private compound_expression_single_quoted ::= <<parseCompoundExpressionSegment single_quoted_string compound_expression_single_quoted_following>>
private compound_expression_single_quoted_following ::= (compound_expression_capture | compound_expression_double_quoted | compound_expression_var | compound_expression_bareword | output_capture | double_quoted_string | variable_ref | compound_expression_bareword_inner)
private compound_expression_double_quoted ::= <<parseCompoundExpressionSegment double_quoted_string compound_expression_double_quoted_following>>
private compound_expression_double_quoted_following ::=  (compound_expression_capture | compound_expression_single_quoted | compound_expression_double_quoted | compound_expression_var | compound_expression_bareword | output_capture | single_quoted_string | double_quoted_string | variable_ref | compound_expression_bareword_inner)
private compound_expression_capture ::= <<parseCompoundExpressionSegment output_capture compound_expression_capture_following>>
private compound_expression_capture_following ::= (compound_expression_capture | compound_expression_single_quoted | compound_expression_double_quoted | compound_expression_var | compound_expression_bareword | output_capture | single_quoted_string | double_quoted_string | variable_ref | compound_expression_bareword_inner)
private compound_expression_bareword ::= <<parseCompoundExpressionSegment compound_expression_bareword_inner compound_expression_bareword_following>>
private compound_expression_bareword_following ::= compound_expression_capture | compound_expression_single_quoted | compound_expression_double_quoted | compound_expression_var | output_capture | single_quoted_string | double_quoted_string | variable_ref
private compound_expression_bareword_inner ::= COMMAND_BAREWORD | BAREWORD | VARIABLE
escaped_sequence ::= ESCAPED_QUOTED_TEXT
invalid_escape_sequence ::= INVALID_ESCAPED_QUOTED_TEXT
private TEXT_CHR ::= TEXT | invalid_escape_sequence | escaped_sequence
private string ::= TEXT_CHR*
single_quoted_string ::= SINGLE_QUOTE string SINGLE_QUOTE
double_quoted_string ::= DOUBLE_QUOTE string DOUBLE_QUOTE
private line_terminator ::= EOL+

// captures

output_capture ::= pipeline_output_body | command_outpub_body
private command_outpub_body ::= QUESTION?OPEN_PARAN pipeline_element CLOSE_PARAN
private pipeline_output_body ::= QUESTION?OPEN_PARAN pipeline CLOSE_PARAN

// special commands

private special_command ::= fn_statement | delete_statement | if_statement | while_statement | for_statement | try_statement
if_statement ::= KEYWORD_IF condition block elif_statement* else_statement?
try_statement ::= KEYWORD_TRY block except_statement? else_statement? finally_statement?
while_statement ::= KEYWORD_WHILE condition block else_statement?
for_statement ::= KEYWORD_FOR variable_declaration collection block else_statement?
delete_statement ::= KEYWORD_DEL VARIABLE(variable_index)?
fn_statement ::= KEYWORD_FN VARIABLE (no_arg_lambda | arg_lambda)

elif_statement ::= KEYWORD_ELIF condition block
else_statement ::= KEYWORD_ELSE block
except_statement ::= KEYWORD_EXCEPT variable_declaration block
finally_statement ::= KEYWORD_FINALLY block

condition ::= variable_ref | output_capture
collection ::= variable_ref | output_capture | map_or_list
block ::= OPEN_BRACE block_body CLOSE_BRACE
private block_body ::= <<parseBlockBody command>>
// variables

variable_declaration ::= VARIABLE {
    implements="com.intellij.psi.PsiNamedElement"
}
variable_ref ::= VAR_REF(variable_index)*
variable_index ::= (OPEN_BRACKET)assignable_string(CLOSE_BRACKET)

// lambdas

lambda ::= arg_lambda | no_arg_lambda
parameter ::= VARIABLE | AT_VARIABLE | option
private option ::= AMPERSAND(bareword)EQUALS(option_default)
private option_default ::= map_or_list | empty_map | single_quoted_string | double_quoted_string | bareword
private arg_lambda ::= OPEN_BRACKET parameter* AT_VARIABLE? CLOSE_BRACKET(no_arg_lambda)
private no_arg_lambda ::= OPEN_BRACE block_body CLOSE_BRACE